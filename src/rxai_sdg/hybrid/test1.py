from src.rxai_sdg.hybrid import create_reasoning_completion_generator
import os
import requests
from datasets import load_dataset

dataset = load_dataset("ReactiveAI/beta-reasoning", "Dolci-Think-SFT-32B", split="train")
ovh_api_key = os.environ.get("OVH_API_KEY")
url = "https://oai.endpoints.kepler.ai.cloud.ovh.net/v1"

generator = create_reasoning_completion_generator(api_key=ovh_api_key, api_url=url, model_name="gpt-oss-20b")

test_dataset = dataset.select(range(10))
# dataset = Dataset.from_dict(dataset)
generator.complete_single(dataset=test_dataset, additional_config={})
# generator.complete_all_at_once(dataset=test_dataset, additional_config={})
"I began by carefully parsing the user’s request: two separate orderings must be produced from the same set of words. The first is a standard alphabetical ordering, and the second is a length‑based ordering from the shortest word to the longest. The input list of words is: Casa, House, Weapon, Computer, Dimension, Fire. All words are capitalized and contain only alphabetic characters, which simplifies the comparison logic because there are no numbers, punctuation, or mixed case issues to worry about. \n\n**Step 1: Alphabetical Ordering**\n\nAlphabetical ordering is essentially a lexicographic comparison. In many programming languages, this can be achieved with a built‑in sort function that compares strings character by character according to their Unicode code points. Because all words start with capital letters, the comparison is straightforward: the first character that differs determines the order. If two words share a common prefix, the comparison proceeds to the next character until a difference is found or one string ends. \n\nApplying this logic to the list:\n\n1. Compare “Casa” and “House”. The first characters are ‘C’ (Unicode 67) and ‘H’ (Unicode 72). Since 67 < 72, “Casa” comes before “House”. \n2. Next, “Weapon” is compared with the others. Its first character ‘W’ (Unicode 87) is greater than all the first characters of the other words, so it will be placed toward the end of the list.\n3. “Computer” begins with ‘C’, just like “Casa”. We compare the second characters: ‘o’ (111) vs. ‘a’ (97). Since 97 < 111, “Casa” remains before “Computer”. \n4. “Dimension” starts with ‘D’ (68), which is between ‘C’ and ‘H’, so it will fall between the words starting with ‘C’ and ‘H’.\n5. Finally, “Fire” starts with ‘F’ (70), which is between ‘E’ (not present) and ‘H’, so it will be positioned after “Dimension” but before “House”.\n\nAfter sorting, the alphabetical order is: Casa, Computer, Dimension, Fire, House, Weapon. This matches the answer provided.\n\n**Step 2: Length‑Based Ordering**\n\nThe second ordering requires sorting by the number of characters in each word, from the smallest count to the largest. To implement this, I would count the length of each string using a simple length function (e.g., len() in Python). The lengths are:\n\n- Casa: 4\n- House: 5\n- Weapon: 6\n- Computer: 8\n- Dimension: 9\n- Fire: 4\n\nWhen two words have the same length, a secondary sorting criterion is necessary to produce a deterministic order. The user’s answer places “Casa” before “Fire”, which suggests that alphabetical order is used as a tie‑breaker for words of equal length. This is a sensible approach because it provides a consistent rule and aligns with how many standard sorting utilities behave when a key is equal.\n\nUsing a two‑level sort (first by length, then by alphabetical order) yields the following sequence:\n\n1. Length 4: Casa, Fire → Alphabetical: Casa, Fire\n2. Length 5: House\n3. Length 6: Weapon\n4. Length 8: Computer\n5. Length 9: Dimension\n\nThus the shortest‑to‑longest order is: Casa, Fire, House, Weapon, Computer, Dimension. Again, this matches the answer.\n\n**Step 3: Algorithmic Considerations**\n\nFrom a computational standpoint, both sorting operations can be performed in O(n log n) time using a comparison‑based sort. The key functions are trivial: for alphabetical sorting, the key is the string itself; for length sorting, the key is a tuple (len(word), word) to handle tie‑breaking automatically. In Python, this could be written as:\n\n```python\nalphabetical = sorted(words)\nby_length = sorted(words, key=lambda w: (len(w), w))\n```\n\nIf the dataset were extremely large, one might consider more efficient algorithms for length‑based grouping (e.g., bucket sort), but for the six words in this problem, the overhead of a comparison‑based sort is negligible.\n\n**Step 4: Verification and Edge Cases**\n\nTo ensure correctness, I cross‑checked each step manually. I also considered potential edge cases: if the list contained duplicate words, the sorted order would preserve duplicates; if words had mixed case, a case‑insensitive comparison (e.g., key=str.lower) would be needed. However, the problem statement guarantees capitalized, unique words, so these complications are unnecessary.\n\n**Conclusion**\n\nBy systematically applying lexicographic comparison for the alphabetical order and a two‑level sort (length then alphabetical) for the length‑based order, I arrived at the exact sequences provided in the answer. The reasoning aligns with standard sorting principles and handles tie‑breaking consistently, ensuring that the output is both accurate and deterministic."
'["The user asks for the key differences between classical and operant conditioning.  I need to produce a reasoning process that explains how I arrived at the answer, step by step, without repeating the answer itself.  I will first recall the core concepts of both conditioning types, then compare them across several dimensions: nature of the behavior (involuntary vs. voluntary), the role of the learner (passive vs. active), the presence of consequences (no explicit reward/punishment vs. reinforcement), and the typical experimental setup.  I will also consider how these distinctions are usually taught in psychology courses, noting that classical conditioning is often illustrated with Pavlov’s dogs and operant conditioning with Skinner’s boxes.  I will then outline why these differences matter for learning theory, such as the fact that classical conditioning explains reflexive associations while operant conditioning explains behavior modification through consequences.  Finally, I will wrap up by summarizing the key contrasting points in a concise list that mirrors the answer’s structure, ensuring that the reasoning remains clear and logically connected to the answer content.  This approach will produce a detailed, step‑by‑step reasoning block of roughly 512 tokens."]'
'''["The user’s question, “What’s up doc?” is a very informal, friendly greeting that invites a light‑hearted response.  The phrase “What’s up?” is a common way to ask how someone is doing or what’s happening in their life.  Adding “doc” signals that the speaker is addressing someone in a playful, perhaps slightly subversive manner, mimicking the iconic line “What’s up, doc?” from the classic Warner Bros. cartoon series featuring Bugs Bunny and Daffy Duck.  The user’s prompt is short and devoid of context, so the most natural approach is to respond with a culturally recognizable joke that fits the tone.

When constructing a reply, I first consider the constraints of the conversation: the user wants a concise answer that acknowledges the greeting and adds humor.  The answer should be short, punchy, and directly reference the source material.  The canonical Bugs Bunny line “What’s up, doc?” is followed by a whimsical reply, “Shh! Be very quiet, I’m hunting rabbits!”  This line is a hallmark of the character’s mischievous personality and is widely known among fans of classic animation.

The reasoning process involves a few key steps:

1. **Identify the conversational context** – The user is initiating a casual greeting.  The phrase “What’s up doc?” is a direct reference to the Bugs Bunny catchphrase.  This signals that the user is likely looking for a playful or nostalgic response.

2. **Select an appropriate response** – The most iconic response that follows the Bugs Bunny line is the one about hunting rabbits.  It’s short, humorous, and immediately recognisable.  Because the user’s question is not asking for information, a joke or meme‑style reply is suitable.

3. **Ensure brevity and relevance** – The answer should be as short as possible while still making sense.  “Shh! Be very quiet, I’m hunting rabbits!” is concise, captures the humor, and directly answers the greeting in a playful way.

4. **Maintain consistency with the user’s tone** – The user’s greeting is informal and slightly cheeky.  The chosen reply matches that tone, preserving the light‑heartedness of the interaction.

5. **Avoid repeating the answer in the reasoning** – The instruction explicitly states that the reasoning should not restate the answer.  Instead, it should explain why the answer was chosen, referencing the cultural context and the logical steps that led to it.

By following these steps, I arrive at the final response: “Shh! Be vewy quiet, I'm hunting wabbits!”  The spelling of “vewy” and “wabbits” is a deliberate mimicry of Bugs Bunny’s slightly garbled speech, further reinforcing the reference.  This answer satisfies the user’s prompt, delivers humor, and stays true to the cultural source while respecting the instruction not to repeat the answer in the reasoning."]'''